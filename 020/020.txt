考慮一個數列 A = (a[1], a[2], a[3], ..., a[n] )。如果 A中兩個數 a[i]和 a[j]滿足 i < j 且 a[i] > a[j]，則說 (a[i], a[j])是 A中的一個 反序 (inversion)。
定義W(A)為數列A中反序數量。例如，在數列 A = (3, 1, 9, 8, 9, 2)中，共有 (3, 1)、(3, 2)、(9, 8)、(9, 2)、 (8, 2)、(9, 2) 6個反序 ，所以 W(A) =6。

計算 W(A)簡單方法是對所有1 <= i < j <= n檢查數對(a[i], a[j])，但在序列太長時，計算時間會超過給定時限。
以下運用分而治之(divide and conquer)策略所設計更有效率方法。
將A等分為前後兩個數列 X 與 Y，其中 X的長度是 n/2。
遞迴計算 W(X) 和W(Y)。
計算W(A) = W(X) + W(Y) + S(X, Y)，其中 S(X, Y)是由 X中的數字與 Y中的數字構成的反序數量 。

以 A = (3, 1, 9, 8, 9, 2) 為例，W(A) 計算如下。
將 A 分為兩個數列 X = (3, 1, 9) 與 Y = (8, 9, 2)。
遞迴計算得到 W(X) = 1和 W(Y) = 2。
計算 S(X, Y) = 3。因為有三個反序 (3, 2)、(9, 8)、(9, 2)是由 X中的數字與中的數字與 Y中的數字所構成。
所以得到 W(A) = W(X) + W(Y) + S(X, Y) = 1+2+3 = 6。

請撰寫一個程式，計算一個數列 A的反序數量 W(A)。

-----------------
輸入格式:
測試資料有兩列，第一列為一個正整數 n，代表A的長度。
第二列有 n個不大於 10^6的非負整數，代表 a[1], a[2], a[3], ..., a[n]，數字間以空白隔開 。

-----------------
輸出格式:
A的反序數量 W(A)。可能超過32-bit 整數範圍。

-------------
Sample Input:
6
3 1 9 8 9 2
-------------
Sample Output:
6

-------------
Sample Input:
5
5 5 4 3 1
-------------
Sample Output:
9